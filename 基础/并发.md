进程 线程



线程的生命周期和状态

 线程6 种不同状态



上下文切换

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。



 sleep() 方法和 wait() 方法区别和共同点?

两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。
两者都可以暂停线程的执行。
Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。
wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。



为什么调用 start() 方法时会执行 run() 方法，不能直接调用 run() 方法

新建线程进入新建状态，调用 start() 方法，线程启动并进入就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。

而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。





常用的线程池有几种？这几种线程池之间有什么区别和联系





线程池的实现原理





多线程同步





synchronized和ReentrantLock的区别



synchronized锁普通方法和锁静态方法、死锁的原理及排查方法





CyclicBarrier和CountDownLatch的区别





ThreadLocal



Callable接口



怎么检测一个线程是否持有对象监视器





ConcurrentHashMap的并发度是什么



ReadWriteLock是什么



FutureTask是什么





Linux环境下如何查找哪个线程使用CPU最长





如果你提交任务时，线程池队列已满，这时会发生什么



Java中用到的线程调度算法是什么



Thread.sleep(0)的作用是什么



**什么是自旋**



**什么是Java内存模型**





**什么是AQS**





**单例模式的线程安全性**



**Semaphore有什么作用**





**Hashtable的size()方法中明明只有一条语句"return count"，为什么还要做同步？**





**高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？**



常用的锁有哪几种？ReentrantLock可重入锁是怎么实现的？简述下死锁的造成与解决/避免



Volatile关键字能否保证并发安全。



线程池的实现原理





Object类中的方法以及每个方法的作用





（1）List、Map、Set实现类的源代码

（2）ReentrantLock、AQS的源代码

（3）AtomicInteger的实现原理，主要能说清楚CAS机制并且AtomicInteger是如何利用CAS机制实现的





